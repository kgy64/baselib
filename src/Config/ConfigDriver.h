#ifndef __CONFIGDRIVER_H__
#define __CONFIGDRIVER_H__

#include <File/FileMapTyped.h>
#include <Debug/Debug.h>

#include <boost/shared_ptr.hpp>
#include <map>

class ConfExpression;
class AssignmentSet;
class ConfAssign;
class ConfDriver;
class ConfigLevel;

typedef boost::shared_ptr<ConfExpression> ConfigValue;

#include <Config/ConfigHandler.hpp> // Generated by bison

SYS_DECLARE_MODULE(DM_CONFIG);

class ConfigStore
{
 public:
    ConfigStore(void)
    {
    }

    void SetConfig(AssignmentSet * assigns)
    {
        theConfig = boost::shared_ptr<AssignmentSet>(assigns);
    }

    void List(void) const;
    const ConfigValue GetConfig(const std::string & key) const;

 private:
    SYS_DEFINE_CLASS_NAME("ConfigStore");

    boost::shared_ptr<AssignmentSet> theConfig;
};

class ConfDriver
{
 public:
    ConfDriver(FILES::FileMap_char & file_2_parse, ConfigStore & store);
    ConfDriver(const char * data, int length, ConfigStore & store);

    int parse();
    void error(const yy::location & loc, const std::string & message);
    void AddError(void);
    int yylex(yy::ConfParser::semantic_type & yylval, yy::ConfParser::location_type & yylloc);
    int lexical_analyzer(yy::ConfParser::semantic_type & yylval);

    void Declare(AssignmentSet * assigns)
    {
        configStore.SetConfig(assigns);
    }

 private:
    SYS_DEFINE_CLASS_NAME("ConfDriver");

    int ChrGet(void);
    void UnGet(void);

    FILES::FileMap_char * file;

    const char * myData;
    int myLength;
    int myPosition;

    int lineNo;
    int column;

    ConfigStore & configStore;
};

typedef boost::shared_ptr<ConfDriver> ConfDriverPtr;

static std::ostream & operator<<(std::ostream & os, const ConfExpression & ex);

class ConfExpression
{
 friend std::ostream & operator<<(std::ostream & os, const ConfExpression & ex);

 public:
    ConfExpression(const std::string & value);
    VIRTUAL_IF_DEBUG ~ConfExpression();

    const std::string & GetString(void) const { return myValue; }

    const int * ToInt(void) const { return iValue.Value_p; }

    const float * ToFloat(void) const { return fValue.Value_p; }

    const double * ToDouble(void) const { return dValue.Value_p; }

    void reference(void)
    {
        SYS_DEBUG_MEMBER(DM_CONFIG);
        ++reference_counter;
        SYS_DEBUG(DL_INFO2, "Refernced: " << reference_counter);
    }

    void unreference(void)
    {
        SYS_DEBUG_MEMBER(DM_CONFIG);
        if (--reference_counter) {
            SYS_DEBUG(DL_INFO2, "Refernced: " << reference_counter);
            return;
        }
        SYS_DEBUG(DL_INFO2, "To be deleted...");
        delete this;
    }

    void Sign(void)
    {
        *iValue.Value_p = - *iValue.Value_p;
        *fValue.Value_p = - *fValue.Value_p;
        *dValue.Value_p = - *dValue.Value_p;
    }

 private:
    SYS_DEFINE_CLASS_NAME("ConfExpression");

    std::string myValue;

    template <typename T>
    struct Value_t
    {
        void Validate(bool ok)
        {
            Value_p = ok ? &Value : NULL;
        }

        T Value;

        T * Value_p;
    };

    Value_t<int> iValue;

    Value_t<float> fValue;

    Value_t<double> dValue;

    int reference_counter;
};

static inline std::ostream & operator<<(std::ostream & os, const ConfExpression & ex)
{
 os << ex.myValue;
 return os;
}

static std::ostream & operator<<(std::ostream & os, const ConfAssign & as);

class ConfAssign
{
 friend std::ostream & operator<<(std::ostream & os, const ConfAssign & as);

 public:
    ConfAssign(ConfigValue & name, ConfigValue & value):
        reference_counter(1),
        myName(name),
        myValue(value)
    {
        SYS_DEBUG_MEMBER(DM_CONFIG);
    }

    VIRTUAL_IF_DEBUG ~ConfAssign()
    {
        SYS_DEBUG_MEMBER(DM_CONFIG);
    }

    ConfigValue & GetName(void) { return myName; }

    ConfigValue & GetValue(void) { return myValue; }

    void reference(void)
    {
        SYS_DEBUG_MEMBER(DM_CONFIG);
        ++reference_counter;
        SYS_DEBUG(DL_INFO2, "Refernced: " << reference_counter);
    }

    void unreference(void)
    {
        SYS_DEBUG_MEMBER(DM_CONFIG);
        if (--reference_counter) {
            SYS_DEBUG(DL_INFO2, "Refernced: " << reference_counter);
            return;
        }
        SYS_DEBUG(DL_INFO2, "To be deleted...");
        delete this;
    }

 private:
    SYS_DEFINE_CLASS_NAME("ConfAssign");

    int reference_counter;

    ConfigValue myName;
    ConfigValue myValue;
};

static inline std::ostream & operator<<(std::ostream & os, const ConfAssign & as)
{
 os << "Assign(" << as.myName << "=" << as.myValue << ")";
 return os;
}

static std::ostream & operator<<(std::ostream & os, const AssignmentSet & body);

typedef boost::shared_ptr<ConfigLevel> ConfPtr;

class AssignmentSet
{
 friend std::ostream & operator<<(std::ostream & os, const AssignmentSet & body);

 public:
    AssignmentSet(void):
        reference_counter(1)
    {
        SYS_DEBUG_MEMBER(DM_CONFIG);
    }

    VIRTUAL_IF_DEBUG ~AssignmentSet()
    {
        SYS_DEBUG_MEMBER(DM_CONFIG);
        SYS_DEBUG(DL_INFO2, "Size was " << assigns.size() << "/" << subConfigs.size());
    }

    const ConfigValue GetConfig(const std::string & key) const;
    AssignmentSet * Append(ConfAssign * assignment);
    AssignmentSet * Append(ConfigLevel * conf);
    AssignmentSet * Append(AssignmentSet * other);
    const std::string * GetValue(const std::string & name);
    const ConfPtr GetSubconfig(const std::string & name);
    void List(int level) const;

    size_t noOfAssignments(void) const
    {
        return assigns.size();
    }

    size_t noOfSubconfigs(void) const
    {
        return subConfigs.size();
    }

    void reference(void)
    {
        SYS_DEBUG_MEMBER(DM_CONFIG);
        ++reference_counter;
        SYS_DEBUG(DL_INFO2, "Refernced: " << reference_counter);
    }

    void unreference(void)
    {
        SYS_DEBUG_MEMBER(DM_CONFIG);
        if (--reference_counter) {
            SYS_DEBUG(DL_INFO2, "Refernced: " << reference_counter);
            return;
        }
        SYS_DEBUG(DL_INFO2, "To be deleted...");
        delete this;
    }

 private:
    SYS_DEFINE_CLASS_NAME("AssignmentSet");

    typedef std::map<std::string, ConfigValue> AssignContainer;

    AssignContainer assigns;

    typedef std::map<std::string, boost::shared_ptr<ConfigLevel> > ConfigContainer;

    ConfigContainer subConfigs;

    int reference_counter;
};

static inline std::ostream & operator<<(std::ostream & os, const AssignmentSet & body)
{
 os << "AssignmentSet(" << body.assigns.size() << "/" << body.subConfigs.size() << ")";
 return os;
}

class ConfigLevel
{
 public:
    ConfigLevel(ConfigValue & name, AssignmentSet * body):
        levelName(name->GetString()),
        assignments(body),
        reference_counter(1)
    {
    }

    VIRTUAL_IF_DEBUG ~ConfigLevel()
    {
        SYS_DEBUG_MEMBER(DM_CONFIG);
        SYS_DEBUG(DL_INFO2, "Name was: " << levelName);
    }

    const std::string & GetName(void) const
    {
        return levelName;
    }

    const AssignmentSet & GetAssignments(void) const
    {
        return *assignments;
    }

    const ConfigValue GetConfig(const std::string & key) const;
    void List(int level) const;

    void reference(void)
    {
        SYS_DEBUG_MEMBER(DM_CONFIG);
        ++reference_counter;
        SYS_DEBUG(DL_INFO2, "Refernced: " << reference_counter);
    }

    void unreference(void)
    {
        SYS_DEBUG_MEMBER(DM_CONFIG);
        if (--reference_counter) {
            SYS_DEBUG(DL_INFO2, "Refernced: " << reference_counter);
            return;
        }
        SYS_DEBUG(DL_INFO2, "To be deleted...");
        delete this;
    }

 private:
    SYS_DEFINE_CLASS_NAME("ConfigLevel");

    std::string levelName;
    boost::shared_ptr<AssignmentSet> assignments;

    int reference_counter;
};

static inline std::ostream & operator<<(std::ostream & os, const ConfigLevel & conf)
{
 os << conf.GetName() << "(" << conf.GetAssignments().noOfAssignments() << "/"
                             << conf.GetAssignments().noOfSubconfigs() << ")";
 return os;
}

#endif /* __CONFIGDRIVER_H__ */

/* * * * * * * * * * * * * End - of - File * * * * * * * * * * * * * * */
